/*******************************************************************************
 * Copyright (c) 2011 Sebastian Benz.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Sebastian Benz - initial API and implementation
 *******************************************************************************/
/*
* generated by Xtext
*/

package de.sebastianbenz.task.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class TaskPaperGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class TodoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Todo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTodoAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cContentsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cContentsContentParserRuleCall_1_0_0 = (RuleCall)cContentsAssignment_1_0.eContents().get(0);
		private final RuleCall cSpacesParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Todo:
		//	{Todo} (contents+=Content | Spaces)* WS*;
		public ParserRule getRule() { return rule; }

		//{Todo} (contents+=Content | Spaces)* WS*
		public Group getGroup() { return cGroup; }

		//{Todo}
		public Action getTodoAction_0() { return cTodoAction_0; }

		//(contents+=Content | Spaces)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//contents+=Content
		public Assignment getContentsAssignment_1_0() { return cContentsAssignment_1_0; }

		//Content
		public RuleCall getContentsContentParserRuleCall_1_0_0() { return cContentsContentParserRuleCall_1_0_0; }

		//Spaces
		public RuleCall getSpacesParserRuleCall_1_1() { return cSpacesParserRuleCall_1_1; }

		//WS*
		public RuleCall getWSTerminalRuleCall_2() { return cWSTerminalRuleCall_2; }
	}

	public class ContentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Content");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProjectParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTaskParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNoteParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// *
		//Project
		//WS TASK
		//WS PROJECT
		//WS WS TASK
		//WS WS PROJECT
		// * / Content:
		//	Project | Task | Note;
		public ParserRule getRule() { return rule; }

		//Project | Task | Note
		public Alternatives getAlternatives() { return cAlternatives; }

		//Project
		public RuleCall getProjectParserRuleCall_0() { return cProjectParserRuleCall_0; }

		//Task
		public RuleCall getTaskParserRuleCall_1() { return cTaskParserRuleCall_1; }

		//Note
		public RuleCall getNoteParserRuleCall_2() { return cNoteParserRuleCall_2; }
	}

	public class TaskElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Task");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIntendAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIntendWSTerminalRuleCall_0_0 = (RuleCall)cIntendAssignment_0.eContents().get(0);
		private final Assignment cTextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTextTASK_TEXTTerminalRuleCall_1_0 = (RuleCall)cTextAssignment_1.eContents().get(0);
		
		//Task:
		//	intend+=WS* text=TASK_TEXT;
		public ParserRule getRule() { return rule; }

		//intend+=WS* text=TASK_TEXT
		public Group getGroup() { return cGroup; }

		//intend+=WS*
		public Assignment getIntendAssignment_0() { return cIntendAssignment_0; }

		//WS
		public RuleCall getIntendWSTerminalRuleCall_0_0() { return cIntendWSTerminalRuleCall_0_0; }

		//text=TASK_TEXT
		public Assignment getTextAssignment_1() { return cTextAssignment_1; }

		//TASK_TEXT
		public RuleCall getTextTASK_TEXTTerminalRuleCall_1_0() { return cTextTASK_TEXTTerminalRuleCall_1_0; }
	}

	public class NoteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Note");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIntendAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIntendWSTerminalRuleCall_0_0 = (RuleCall)cIntendAssignment_0.eContents().get(0);
		private final Assignment cTextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTextTEXTTerminalRuleCall_1_0 = (RuleCall)cTextAssignment_1.eContents().get(0);
		
		//Note:
		//	intend+=WS* text=TEXT;
		public ParserRule getRule() { return rule; }

		//intend+=WS* text=TEXT
		public Group getGroup() { return cGroup; }

		//intend+=WS*
		public Assignment getIntendAssignment_0() { return cIntendAssignment_0; }

		//WS
		public RuleCall getIntendWSTerminalRuleCall_0_0() { return cIntendWSTerminalRuleCall_0_0; }

		//text=TEXT
		public Assignment getTextAssignment_1() { return cTextAssignment_1; }

		//TEXT
		public RuleCall getTextTEXTTerminalRuleCall_1_0() { return cTextTEXTTerminalRuleCall_1_0; }
	}

	public class ProjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Project");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIntendAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIntendWSTerminalRuleCall_0_0 = (RuleCall)cIntendAssignment_0.eContents().get(0);
		private final Assignment cTextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTextPROJECT_TerminalRuleCall_1_0 = (RuleCall)cTextAssignment_1.eContents().get(0);
		
		//Project:
		//	intend+=WS* text=PROJECT_;
		public ParserRule getRule() { return rule; }

		//intend+=WS* text=PROJECT_
		public Group getGroup() { return cGroup; }

		//intend+=WS*
		public Assignment getIntendAssignment_0() { return cIntendAssignment_0; }

		//WS
		public RuleCall getIntendWSTerminalRuleCall_0_0() { return cIntendWSTerminalRuleCall_0_0; }

		//text=PROJECT_
		public Assignment getTextAssignment_1() { return cTextAssignment_1; }

		//PROJECT_
		public RuleCall getTextPROJECT_TerminalRuleCall_1_0() { return cTextPROJECT_TerminalRuleCall_1_0; }
	}

	public class SpacesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Spaces");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Spaces:
		//	WS* NL;
		public ParserRule getRule() { return rule; }

		//WS* NL
		public Group getGroup() { return cGroup; }

		//WS*
		public RuleCall getWSTerminalRuleCall_0() { return cWSTerminalRuleCall_0; }

		//NL
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }
	}
	
	
	private TodoElements pTodo;
	private ContentElements pContent;
	private TaskElements pTask;
	private NoteElements pNote;
	private ProjectElements pProject;
	private SpacesElements pSpaces;
	private TerminalRule tWS;
	private TerminalRule tNL;
	private TerminalRule tTASK_TEXT;
	private TerminalRule tTEXT;
	private TerminalRule tPROJECT_;
	private TerminalRule tCOLON;
	private TerminalRule tHYPHEN;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public TaskPaperGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	//Todo:
	//	{Todo} (contents+=Content | Spaces)* WS*;
	public TodoElements getTodoAccess() {
		return (pTodo != null) ? pTodo : (pTodo = new TodoElements());
	}
	
	public ParserRule getTodoRule() {
		return getTodoAccess().getRule();
	}

	/// *
	//Project
	//WS TASK
	//WS PROJECT
	//WS WS TASK
	//WS WS PROJECT
	// * / Content:
	//	Project | Task | Note;
	public ContentElements getContentAccess() {
		return (pContent != null) ? pContent : (pContent = new ContentElements());
	}
	
	public ParserRule getContentRule() {
		return getContentAccess().getRule();
	}

	//Task:
	//	intend+=WS* text=TASK_TEXT;
	public TaskElements getTaskAccess() {
		return (pTask != null) ? pTask : (pTask = new TaskElements());
	}
	
	public ParserRule getTaskRule() {
		return getTaskAccess().getRule();
	}

	//Note:
	//	intend+=WS* text=TEXT;
	public NoteElements getNoteAccess() {
		return (pNote != null) ? pNote : (pNote = new NoteElements());
	}
	
	public ParserRule getNoteRule() {
		return getNoteAccess().getRule();
	}

	//Project:
	//	intend+=WS* text=PROJECT_;
	public ProjectElements getProjectAccess() {
		return (pProject != null) ? pProject : (pProject = new ProjectElements());
	}
	
	public ParserRule getProjectRule() {
		return getProjectAccess().getRule();
	}

	//Spaces:
	//	WS* NL;
	public SpacesElements getSpacesAccess() {
		return (pSpaces != null) ? pSpaces : (pSpaces = new SpacesElements());
	}
	
	public ParserRule getSpacesRule() {
		return getSpacesAccess().getRule();
	}

	//terminal WS:
	//	" " | "\t";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal NL:
	//	"\r"? "\n";
	public TerminalRule getNLRule() {
		return (tNL != null) ? tNL : (tNL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NL"));
	} 

	//terminal TASK_TEXT:
	//	HYPHEN !("\n" | "\r")* NL;
	public TerminalRule getTASK_TEXTRule() {
		return (tTASK_TEXT != null) ? tTASK_TEXT : (tTASK_TEXT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TASK_TEXT"));
	} 

	//terminal TEXT:
	//	!(HYPHEN | "\n" | "\r" | WS) !("\n" | "\r")* !(COLON | "\n" | "\r") NL;
	public TerminalRule getTEXTRule() {
		return (tTEXT != null) ? tTEXT : (tTEXT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TEXT"));
	} 

	//terminal PROJECT_:
	//	!("\n" | "\r" | HYPHEN | WS) !("\n" | "\r")* COLON NL;
	public TerminalRule getPROJECT_Rule() {
		return (tPROJECT_ != null) ? tPROJECT_ : (tPROJECT_ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PROJECT_"));
	} 

	//terminal fragment COLON:
	//	":";
	public TerminalRule getCOLONRule() {
		return (tCOLON != null) ? tCOLON : (tCOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COLON"));
	} 

	//terminal fragment HYPHEN:
	//	"-";
	public TerminalRule getHYPHENRule() {
		return (tHYPHEN != null) ? tHYPHEN : (tHYPHEN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HYPHEN"));
	} 
}
